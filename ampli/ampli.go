// ampli.go
//
// Ampli - A strong typed wrapper for your Analytics
//
// This file is generated by Amplitude.
// To update run 'ampli pull go-sample-app'
//
// Required dependencies: github.com/amplitude/analytics-go/amplitude@v0.0.5
// Tracking Plan Version: 1
// Build: 1.0.0
// Runtime: go-ampli
//
// View Tracking Plan: https://data.amplitude.com/codedbychavez/ab-testing-in-go/events/main/latest
//
// Full Setup Instructions: https://data.amplitude.com/codedbychavez/ab-testing-in-go/implementation/main/latest/getting-started/go-sample-app
//

package ampli

import (
	"log"
	"sync"

	"github.com/amplitude/analytics-go/amplitude"
)

type (
	EventOptions  = amplitude.EventOptions
	ExecuteResult = amplitude.ExecuteResult
)

const (
	IdentifyEventType      = amplitude.IdentifyEventType
	GroupIdentifyEventType = amplitude.GroupIdentifyEventType

	ServerZoneUS = amplitude.ServerZoneUS
	ServerZoneEU = amplitude.ServerZoneEU
)

var (
	NewClientConfig = amplitude.NewConfig
	NewClient       = amplitude.NewClient
)

var Instance = Ampli{}

type Environment string

const (
	EnvironmentDevelopment Environment = `development`

	EnvironmentProduction Environment = `production`
)

var APIKey = map[Environment]string{
	EnvironmentDevelopment: ``,

	EnvironmentProduction: `f0f6506c41bf8cc3a341cd4febf17293`,
}

// LoadClientOptions is Client options setting to initialize Ampli client.
//
// Params:
//   - APIKey: the API key of Amplitude project
//   - Instance: the core SDK instance used by Ampli client
//   - Configuration: the core SDK client configuration instance
type LoadClientOptions struct {
	APIKey        string
	Instance      amplitude.Client
	Configuration amplitude.Config
}

// LoadOptions is options setting to initialize Ampli client.
//
// Params:
//   - Environment: the environment of Amplitude Data project
//   - Disabled: the flag of disabled Ampli client
//   - Client: the LoadClientOptions struct
type LoadOptions struct {
	Environment Environment
	Disabled    bool
	Client      LoadClientOptions
}

type baseEvent struct {
	eventType  string
	properties map[string]interface{}
}

type Event interface {
	ToAmplitudeEvent() amplitude.Event
}

func newBaseEvent(eventType string, properties map[string]interface{}) baseEvent {
	return baseEvent{
		eventType:  eventType,
		properties: properties,
	}
}

func (event baseEvent) ToAmplitudeEvent() amplitude.Event {
	return amplitude.Event{
		EventType:       event.eventType,
		EventProperties: event.properties,
	}
}

var Identify = struct {
	Builder func() IdentifyBuilder
}{
	Builder: func() IdentifyBuilder {
		return &identifyBuilder{
			properties: map[string]interface{}{},
		}
	},
}

type IdentifyEvent interface {
	Event
	identify()
}

type identifyEvent struct {
	baseEvent
}

func (e identifyEvent) identify() {
}

type IdentifyBuilder interface {
	Build() IdentifyEvent
}

type identifyBuilder struct {
	properties map[string]interface{}
}

func (b *identifyBuilder) Build() IdentifyEvent {
	return &identifyEvent{
		newBaseEvent(`Identify`, b.properties),
	}
}

func (e identifyEvent) ToAmplitudeEvent() amplitude.Event {
	identify := amplitude.Identify{}
	for name, value := range e.properties {
		identify.Set(name, value)
	}

	return amplitude.Event{
		EventType:      IdentifyEventType,
		UserProperties: identify.Properties,
	}
}

var Group = struct {
	Builder func() GroupBuilder
}{
	Builder: func() GroupBuilder {
		return &groupBuilder{
			properties: map[string]interface{}{},
		}
	},
}

type GroupEvent interface {
	Event
	group()
}

type groupEvent struct {
	baseEvent
}

func (e groupEvent) group() {
}

type GroupBuilder interface {
	Build() GroupEvent
}

type groupBuilder struct {
	properties map[string]interface{}
}

func (b *groupBuilder) Build() GroupEvent {
	return &groupEvent{
		newBaseEvent(`Group`, b.properties),
	}
}

func (e groupEvent) ToAmplitudeEvent() amplitude.Event {
	identify := amplitude.Identify{}
	for name, value := range e.properties {
		identify.Set(name, value)
	}

	return amplitude.Event{
		EventType:       GroupIdentifyEventType,
		GroupProperties: identify.Properties,
	}
}

var PageView = struct {
	Builder func() PageViewBuilder
}{
	Builder: func() PageViewBuilder {
		return &pageViewBuilder{
			properties: map[string]interface{}{},
		}
	},
}

type PageViewEvent interface {
	Event
	pageView()
}

type pageViewEvent struct {
	baseEvent
}

func (e pageViewEvent) pageView() {
}

type PageViewBuilder interface {
	Build() PageViewEvent
}

type pageViewBuilder struct {
	properties map[string]interface{}
}

func (b *pageViewBuilder) Build() PageViewEvent {
	return &pageViewEvent{
		newBaseEvent(`page_view`, b.properties),
	}
}

type Ampli struct {
	Disabled bool
	Client   amplitude.Client
	mutex    sync.RWMutex
}

// Load initializes the Ampli wrapper.
// Call once when your application starts.
func (a *Ampli) Load(options LoadOptions) {
	if a.Client != nil {
		log.Print("Warn: Ampli is already initialized. Ampli.Load() should be called once at application start up.")

		return
	}

	var apiKey string
	switch {
	case options.Client.APIKey != "":
		apiKey = options.Client.APIKey
	case options.Environment != "":
		apiKey = APIKey[options.Environment]
	default:
		apiKey = options.Client.Configuration.APIKey
	}

	if apiKey == "" && options.Client.Instance == nil {
		log.Print("Error: Ampli.Load() requires option.Environment, " +
			"and apiKey from either options.Instance.APIKey or APIKey[options.Environment], " +
			"or options.Instance.Instance")
	}

	clientConfig := options.Client.Configuration

	if clientConfig.Plan == nil {
		clientConfig.Plan = &amplitude.Plan{
			Branch:    `main`,
			Source:    `go-sample-app`,
			Version:   `1`,
			VersionID: `83d48016-f614-4a44-8fcc-f0fd67bdf88a`,
		}
	}
	
	if clientConfig.IngestionMetadata == nil {
		clientConfig.IngestionMetadata = &amplitude.IngestionMetadata{
			SourceName:    `go-go-ampli`,
			SourceVersion: `2.0.0`,
		}
	}

	if options.Client.Instance != nil {
		a.Client = options.Client.Instance
	} else {
		clientConfig.APIKey = apiKey
		a.Client = amplitude.NewClient(clientConfig)
	}

	a.mutex.Lock()
	a.Disabled = options.Disabled
	a.mutex.Unlock()
}

// InitializedAndEnabled checks if Ampli is initialized and enabled.
func (a *Ampli) InitializedAndEnabled() bool {
	if a.Client == nil {
		log.Print("Error: Ampli is not yet initialized. Have you called Ampli.Load() on app start?")

		return false
	}

	a.mutex.RLock()
	defer a.mutex.RUnlock()

	return !a.Disabled
}

func (a *Ampli) setUserID(userID string, eventOptions *EventOptions) {
	if userID != "" {
		eventOptions.UserID = userID
	}
}

// Track tracks an event.
func (a *Ampli) Track(userID string, event Event, eventOptions ...EventOptions) {
	if !a.InitializedAndEnabled() {
		return
	}

	var options EventOptions
	if len(eventOptions) > 0 {
		options = eventOptions[0]
	}

	a.setUserID(userID, &options)

	baseEvent := event.ToAmplitudeEvent()
	baseEvent.EventOptions = options

	a.Client.Track(baseEvent)
}

// Identify identifies a user and set user properties.
func (a *Ampli) Identify(userID string, eventOptions ...EventOptions) {
	identify := Identify.Builder().Build()
	a.Track(userID, identify, eventOptions...)
}

// GroupIdentify identifies a group and set group properties.
func (a *Ampli) GroupIdentify(groupType string, groupName string, eventOptions ...EventOptions) {
	group := Group.Builder().Build()
	event := group.ToAmplitudeEvent()
	event.Groups = map[string][]string{groupType: {groupName}}
	if len(eventOptions) > 0 {
		event.EventOptions = eventOptions[0]
	}

	a.Client.Track(event)
}

// SetGroup sets group for the current user.
func (a *Ampli) SetGroup(userID string, groupType string, groupName []string, eventOptions ...EventOptions) {
	var options EventOptions
	if len(eventOptions) > 0 {
		options = eventOptions[0]
	}
	a.setUserID(userID, &options)

	a.Client.SetGroup(groupType, groupName, options)
}

// Flush flushes events waiting in buffer.
func (a *Ampli) Flush() {
	if !a.InitializedAndEnabled() {
		return
	}

	a.Client.Flush()
}

// Shutdown disables and shutdowns Ampli Instance.
func (a *Ampli) Shutdown() {
	if !a.InitializedAndEnabled() {
		return
	}

	a.mutex.Lock()
	a.Disabled = true
	a.mutex.Unlock()

	a.Client.Shutdown()
}

func (a *Ampli) PageView(userID string, eventOptions ...EventOptions) {
	event := PageView.Builder().Build()
	a.Track(userID, event, eventOptions...)
}
